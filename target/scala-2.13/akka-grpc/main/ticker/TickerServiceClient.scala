
// Generated by Akka gRPC. DO NOT EDIT.
package ticker

import scala.concurrent.ExecutionContext

import io.grpc.MethodDescriptor

import akka.actor.ClassicActorSystemProvider

import akka.grpc.GrpcClientSettings

import akka.grpc.scaladsl.AkkaGrpcClient

import akka.grpc.internal.Marshaller
import akka.grpc.internal.NettyClientUtils
import akka.grpc.internal.ClientState

import akka.grpc.scaladsl.StreamResponseRequestBuilder
import akka.grpc.internal.ScalaServerStreamingRequestBuilder

// Not sealed so users can extend to write their stubs
trait TickerServiceClient extends TickerService with TickerServiceClientPowerApi with AkkaGrpcClient

object TickerServiceClient {
  def apply(settings: GrpcClientSettings)(implicit sys: ClassicActorSystemProvider): TickerServiceClient =
    new DefaultTickerServiceClient(settings)
}

final class DefaultTickerServiceClient(settings: GrpcClientSettings)(implicit sys: ClassicActorSystemProvider) extends TickerServiceClient {
  import DefaultTickerServiceClient._

  private implicit val ex: ExecutionContext = sys.classicSystem.dispatcher
  private val options = NettyClientUtils.callOptions(settings)
  private val clientState = new ClientState(settings, akka.event.Logging(sys.classicSystem, this.getClass))

  
    private def monitorSymbolRequestBuilder(channel: akka.grpc.internal.InternalChannel) = {
      
        val fqName = "ticker.TickerService.MonitorSymbol"
        
          new ScalaServerStreamingRequestBuilder(monitorSymbolDescriptor, fqName, channel, options, settings)
        
      
    }
  

  
    /**
     * Lower level "lifted" version of the method, giving access to request metadata etc.
     * prefer monitorSymbol(ticker.TickerSymbol) if possible.
     */
    
      override def monitorSymbol(): StreamResponseRequestBuilder[ticker.TickerSymbol, ticker.StockValue] =
        monitorSymbolRequestBuilder(clientState.internalChannel)
    

    /**
     * For access to method metadata use the parameterless version of monitorSymbol
     */
    def monitorSymbol(in: ticker.TickerSymbol): akka.stream.scaladsl.Source[ticker.StockValue, akka.NotUsed] =
      monitorSymbol().invoke(in)
  

  override def close(): scala.concurrent.Future[akka.Done] = clientState.close()
  override def closed: scala.concurrent.Future[akka.Done] = clientState.closed()

}



private object DefaultTickerServiceClient {

  def apply(settings: GrpcClientSettings)(implicit sys: ClassicActorSystemProvider): TickerServiceClient =
    new DefaultTickerServiceClient(settings)

  import TickerService.Serializers._

  
    private val monitorSymbolDescriptor: MethodDescriptor[ticker.TickerSymbol, ticker.StockValue] =
      MethodDescriptor.newBuilder()
        .setType(
  
  
   MethodDescriptor.MethodType.SERVER_STREAMING 
  
)
        .setFullMethodName(MethodDescriptor.generateFullMethodName("ticker.TickerService", "MonitorSymbol"))
        .setRequestMarshaller(new Marshaller(TickerSymbolSerializer))
        .setResponseMarshaller(new Marshaller(StockValueSerializer))
        .setSampledToLocalTracing(true)
        .build()
  
}

trait TickerServiceClientPowerApi {
  
    /**
     * Lower level "lifted" version of the method, giving access to request metadata etc.
     * prefer monitorSymbol(ticker.TickerSymbol) if possible.
     */
    
      def monitorSymbol(): StreamResponseRequestBuilder[ticker.TickerSymbol, ticker.StockValue] = ???
    
  

}
